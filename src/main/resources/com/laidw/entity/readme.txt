注意学生/奶牛和普通任务/调查任务之间的关系比较复杂，比如：
 * 学生可以发布普通任务，接收普通任务，接收调查任务
 * 奶牛可以发布普通任务，发布调查任务
 * 普通任务只能被一个用户接收，而调查任务可以被多个用户接收
显然，具体指出学生和普通任务、学生和调查任务、奶牛和普通任务、奶牛和调查任务之间的关系会很麻烦
因此，我们把学生和奶牛统一当成用户，普通任务和调查任务统一当成任务，这样只需关系用户与任务的关系了
但是这样也有缺点，如果不特别注意的话，可能会出现学生发布调查任务、普通任务被多个学生接收的情况

数据库中除了要有user表和task表外，还需要user_acc_task表，用于存储用户与该用户接收的任务的对应关系
该表除了有uid字段和tid字段之外，还应该有一个is_done字段，用来表示该用户是否已完成该任务
不把is_done字段放在task表中是因为调查任务可以被多个用户接收，这样做会使得牵一发而动全身
另外注意要把is_done字段和task表的is_available字段区分开

关于Task类的isAvailable curCount maxCount属性
最开始只有isAvailable属性，后来发现调查任务有接收人数限制，因此用后两个属性来代替该属性，但后来发现isAvailable属性还是不可缺少的
curCount maxCount属性的作用：可用于表示调查任务的状态，curCount < maxCount说明该任务进行中，相等则说明已结束（不管接收该任务的用户是否已填写了问卷）
isAvailable属性的作用：假设某个调查任务maxCount为300，但过了很久也只有250人接收了该任务，此时该任务显然应该结束，因此提供该属性，让发布者强制结束该任务

问题来了，这3个属性都只和调查认为有关，为什么要把它们放在Task类而不是InvestigatingTask类中呢？
主要是为了方便。任务和其接收者的关系并不存在于task表中，而是存在于user_acc_task表中
如果这3个属性存在于InvestigatingTask类中，在查询可被接收的NormalTask时，除了需要查询task表外，还需要看user_acc_task表中是否有该任务的记录，这样显然比较麻烦
因此把这3个属性当成两类Task的共同属性，这样在查找可接收任务时，只需要查询task表即可

TaskMapper的查询方法的返回值由Task/List<Task>改为TaskTO/List<TaskTO>原因：
用户在查询他发布的任务时，显然需要直到该任务的状态
对于普通任务，状态可为发布但未接收，接收但未完成，已完成
对于调查任务，状态可为进行中（curCount < maxCount），已满员（curCount == maxCount），已结束（isAvailable == false，已结束状态下，用户即使已经接收了该任务，也无法提交问卷的答案了）
可见，对于调查任务，直接返回Task类即可知晓到该任务的状态，而对于普通任务，则需要有isDone属性来表示它的状态，即需要再查询user_acc_task表
普通任务的3个状态可以分别由isDone == null  isDone == false  isDone == true来表示
更正：依旧把任务记录封装成Task类而不是TaskTO类！
因为只是把普通任务封装成TaskTO，而调查任务还是封装成InvestigatingTask，后者不属于前者，因此只能用Task对象统一接收
不过在查看返回的Task对象时，如果发现其Type为NORMAL，则应该意识到它是可以转换成TaskTO对象的